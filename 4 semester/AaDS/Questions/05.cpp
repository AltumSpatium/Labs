// Решение задачи static RMQ для отрезка фиксированной длины с препроцессингом за O(n ) и ответом на запрос за O(1). Реализация

/*
Пусть дан массив A длины N, и дано число K ≤ N. Требуется найти 
минимум в подотрезках длины K данного массива.
Данный алгоритм позволяет находить минимум на подотрезках
фиксированной длины за O(1), с препроцессингом за O(N).
При этом вспомогательной памяти требуется 2*N. Но основным
преимуществом можно считать очень простую реализацию и
понятность. Недостаток – алгоритм не адаптирован для
изменения элементов исходного массива. Т.е. изменение
возможно, но для этого потребуется выполнить порядка
O(K) действий.

Препроцессинг:
Разделим исходный массив A на блоки длиной K-1 
Затем рассчитаем два дополнительных массива B и C
следующим образом:
в B[i] будем хранить минимум на промежутке от начала текущего
блока до i-го элемента;
в C[i] будем хранить минимум на промежутке от i-го элемента
до конца текущего блока.
Например в B[2] будем хранить максимум от A[0] до A[2], а в
С[2] — максимум от A[2] до A[3]. Понятно, что эту операцию можно
выполнить за O(n).

Обработка запроса:
Теперь, с помощью этой нехитрой структуры, можно легко найти
минимум на отрезке длины K. Мы специально сделали блоки длиной
K-1, что бы края любого запроса всегда попадали в два соседних
блока. И, следовательно, при любом запросе, в отрезок будет
входить граница 2-х блоков. Назовем её T. Левый край отрезка — l,
правый — r. Теперь для того что бы получить минимум, нам
необходимо всего лишь взять min(C[l], B[r]).
Действительно C[l] — это минимум на отрезке от l до T,
а B[r] — минимум от T до r, и, следовательно, минимум от
C[l] и B[r], будет минимумом на отрезке от l до r.
*/

// Реализация:

std::vector<int> B, C;

/* Препроцессинг за O(n) */
void preprocessing(std::vector<int> A, int k)
{
	int n = A.size();
	B.resize(n);
	C.resize(n);
	k--;

	// Рассчитываем B:
	for (int i = 0; i < n; i++)
	{
		if (i % k != 0)
			B[i] = min(A[i], B[i - 1]);
		else
			B[i] = A[i];
	}

	// Рассчитываем C:
	C.back() = A.back();
	for (int i = n - 2; i >= 0; i--)
	{
		if ((i + 1) % k != 0)
			c[i] = min(A[i], C[i + 1]);
		else
			C[i] = A[i];
	}
}

/* static RMQ для отрезка фиксированной длины, ответ за O(1) */
int staticRMQ(std::vector<int> A, int l, int k)
{
	preprocessing(A, k);

	return min(C[l], B[l + k - 1]);
}