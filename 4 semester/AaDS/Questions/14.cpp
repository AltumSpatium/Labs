//  Алгоритм Дейкстры. Реализация через кучу

/*
Разобьем все вершины на два множества: уже обработанные и еще нет. Изначально все
вершины необработанные, и расстояния до всех вершин, кроме начальной, равны
бесконечности, расстояние до начальной вершины равно 0.
На каждой итерации из множества необработанных вершин берется вершина с минимальным
расстоянием и обрабатывается: происходит релаксация всех ребер, из нее исходящих,
после чего вершина помещается во множество уже обработанных вершин.
Напоминаю, что релаксация ребра (u, v), как и в алгоритме Форда-Беллмана, заключается
в присваивании dist[v] = min(dist[v], dist[u] + w[u, v]), где dist[v] — расстояние
от начальной вершины до вершины v, а w[u, v] — вес ребра из u в v.
В самой простой реализации алгоритма Дейкстры нужно в начале каждой итерации пройтись
по всем вершинам для того, чтобы выбрать вершину с минимальным расстоянием. Это
достаточно долго, хотя и бывает оправдано в плотных графах, поэтому обычно для
хранения расстояний до вершин используется какая-либо структура данных. Я буду
использовать std::set, просто потому, что не знаю, как изменить элемент в
std::priority_queue =)
Также я предполагаю, что граф представлен в виде vector<vector<pair<int, int> > > edges,
где edges[v] — вектор всех ребер, исходящих из вершины v, причем первое поле
ребра — номер конечной вершины, а второе — вес.
Вершины хранятся в некоторой структуре данных, поддерживающей операции изменения
произвольного элемента и извлечения минимального.
Каждая вершина извлекается ровно один раз, то есть, требуется O(V) извлечений.
В худшем случае, каждое ребро приводит к изменению одного элемента структуры,
то есть, O(E) изменений.
Если вершины хранятся в простом массиве и для поиска минимума используется
алгоритм линейного поиска, временная сложность алгоритма Дейкстры составляет
O(V * V + E) = O(V²).
Если же используется очередь с приоритетами, реализованная на основе
двоичной кучи (или на основе set), то мы получаем O(V log V + E log E) = O(E log V).
Если же очередь с приоритетами была реализована на основе кучи Фибоначчи,
получается наилучшая оценка сложности O(V log V + E).
*/

// Реализация:

void Dijkstra(int v)
{
	// Инициализация
	int n = (int)edges.size();
	dist.assign(n, INF);
	dist[v] = 0;
	set<pair<int, int> > q;
	for (int i = 0; i < n; ++i)
	{
		q.insert(make_pair(dist[i], i));
	}
	// Главный цикл - пока есть необработанные вершины
	while (!q.empty())
	{
		// Достаем вершину с минимальным расстоянием
		pair<int, int> cur = *q.begin();
		q.erase(q.begin());
		// Проверяем всех ее соседей
		for (int i = 0; i < (int)edges[cur.second].size(); ++i)
		{
			// Делаем релаксацию
			if (dist[edges[cur.second][i].first] > cur.first + edges[cur.second][i].second)
			{
				q.erase(make_pair(dist[edges[cur.second][i].first], edges[cur.second][i].first));
				dist[edges[cur.second][i].first] = cur.first + edges[cur.second][i].second;
				q.insert(make_pair(dist[edges[cur.second][i].first], edges[cur.second][i].first));
			}
		}
	}
}