// Очередь с приоритетами. Куча. Реализация вставки элемента в кучу

/*
Очередь с приоритетом (англ. priority queue) — абстрактный тип данных в программировании,
поддерживающий две обязательные операции — добавить элемент и извлечь максимум.
Предполагается, что для каждого элемента можно вычислить его приоритет — действительное
число или в общем случае элемент линейно упорядоченного множества.

Основные методы, реализуемые очередью с приоритетом, следующие:
insert(ключ, значение) — добавляет пару (ключ, значение) в хранилище;
extract_minimum() — возвращает пару (ключ, значение) с минимальным значением ключа,
удаляя её из хранилища.
При этом меньшее значение ключа соответствует более высокому приоритету.
В некоторых случаях более естественен рост ключа вместе с приоритетом. Тогда второй
метод можно назвать extract_maximum().
Есть ряд реализаций в которых обе основные операции выполняются в худшем случае за время,
ограниченное O(log n), где n — количество хранимых пар.

В качестве примера очереди с приоритетом можно рассмотреть список задач работника. Когда
он заканчивает одну задачу, он переходит к очередной — самой приоритетной
(ключ будет величиной, обратной приоритету) — то есть выполняет операцию
извлечения максимума. Начальник добавляет задачи в список, указывая их приоритет,
то есть выполняет операцию добавления элемента.

Куча — это специализированная структура данных типа дерево, которая удовлетворяет свойству
кучи: если B является узлом-потомком узла A, то ключ(A) ≥ ключ(B). Из этого следует,
что элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда
такие кучи называют max-кучами (в качестве альтернативы, если сравнение перевернуть, то
наименьший элемент будет всегда корневым узлом, такие кучи называют min-кучами).

Куча является максимально эффективной реализацией абстрактного типа данных,
который называется очередью с приоритетом.

Удобнее всего двоичную кучу хранить в виде массива a[0..n-1], у которого нулевой элемент,
a[0] — элемент в корне, а потомками элемента a[i] являются a[2i+1] и a[2i+2].
Высота кучи определяется как высота двоичного дерева. То есть она равна количеству
рёбер в самом длинном простом пути, соединяющем корень кучи с одним из её
листьев. Высота кучи есть O(logn), где n — количество узлов дерева.
Чаще всего используют кучи для минимума (когда предок не больше детей) и для максимума
(когда предок не меньше детей).
Двоичные кучи используют, например, для того, чтобы извлекать минимум из набора чисел
за O(logn).

Если в куче изменяется один из элементов, то она может перестать удовлетворять свойству
упорядоченности. Для восстановления этого свойства служат процедуры siftDown
(просеивание вниз) и siftUp (просеивание вверх). Если значение измененного элемента
увеличивается, то свойства кучи восстанавливаются функцией siftDown. Работа
процедуры: если i-й элемент меньше, чем его сыновья, всё поддерево уже является
кучей, и делать ничего не надо. В противном случае меняем местами i-й элемент с
наименьшим из его сыновей, после чего выполняем siftDown для этого сына. Процедура
выполняется за время O(logn).

Если значение измененного элемента уменьшается, то свойства кучи восстанавливаются
функцией siftUp.
Работа процедуры: если элемент больше своего отца, условие 1 соблюдено для всего
дерева, и больше ничего делать не нужно. Иначе, мы меняем местами его с отцом.
После чего выполняем siftUp для этого отца. Иными словами, слишком маленький элемент
всплывает наверх. Процедура выполняется за время O(logn). 
*/

// Реализация:

/* Куча */
class Heap
{
	int h[100000];
	int tail = 0;

	Heap() {}

	/* Просеивание вверх */
	void siftUp(int i)
	{
		while (a[i] < a[(i - 1) / 2])
		{
			swap(a[i], a[(i - 1) / 2]);
			i = (i - 1) / 2;
		}
	}

	/* Вставка элемента в кучу */
	void insert(int key)
	{
		a[tail] = key;
		siftUp(tail);
		tail++;
	}
}