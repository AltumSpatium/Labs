// Поиск LCA. Реализация через двоичный подъем или RMQ

/*
Наименьшим общим предком (англ. least common ancestor) двух узлов u и v
в корневом дереве T называется узел w, который среди всех узлов,
являющихся предками как узла u, так и v, имеет наибольшую глубину.

1) Пусть дано дерево G. На вход поступают запросы вида (V1, V2), для каждого
запроса требуется найти их наименьшего общего предка, т.е. вершину V,
которая лежит на пути от корня до V1, на пути от корня до V2, и из всех
таких вершин следует выбирать самую нижнюю. Иными словами, искомая
вершина V - предок и V1, и V2, и среди всех таких общих предков выбирается
нижний. Очевидно, что наименьший общий предок вершин V1 и V2 - это их общий
предок, лежащий на кратчайшем пути из V1 в V2. В частности, например,
если V1 является предком V2, то V1 является их наименьшим общим предком
На английском эта задача называется задачей LCA - Least Common Ancestor.

Перед тем, как отвечать на запросы, выполним так называемый препроцессинг.
Запустим обход в глубину из корня, который будет строить список посещения
вершин Order (текущая вершина добавляется в список при входе в
эту вершину, а также после каждого возвращения из её сына), нетрудно 
заметить, что итоговый размер этого списка будет O (N). И построим массив
First[1..N], в котором для каждой вершины будет указана позиция в массиве
Order, в которой стоит эта вершина, т.е. Order[First[I]] = I для всех I.
Также с помощью поиска в глубину найдём высоту каждой вершины (расстояние
от корня до неё) - H[1..N].
Как теперь отвечать на запросы? Пусть имеется текущий запрос - пара вершин
V1 и V2. Рассмотрим список Order между индексами First[V1] и First[V2].
Нетрудно заметить, что в этом диапазоне будет находиться и
искомое LCA (V1, V2), а также множество других вершин. Однако
LCA (V1, V2) будет отличаться от остальных вершин тем, что это будет
вершина с наименьшей высотой.
Таким образом, чтобы ответить на запрос, нам нужно просто найти вершину с
наименьшей высотой в массиве Order в диапазоне между First[V1] и
First[V2]. Таким образом, задача LCA сводится к задаче RMQ.

2) Идея
Будем решать задачу LCA, уже умея решать задачу RMQ. Тогда поиск
наименьшего общего предка i-того и j-того элементов сводится к запросу
минимума на отрезке массива, который будет введен позднее.

Препроцессинг
Для каждой вершины T определим глубину с помощью следующей рекурсивной
формулы:
            /0, if u == root(T)
depth(u) = |
           \depth(v)+1, if u == son(v)
Ясно, что глубина вершины элементарным образом поддерживается во время
обхода в глубину.
Запустим обход в глубину из корня, который будет вычислять значения
следующих величин:

1. Cписок глубин посещенных вершин d. Глубина текущей вершины добавляется в
конец списка при входе в данную вершину, а также после каждого возвращения
из её сына.
2. Список посещений узлов vtx, строящийся аналогично предыдущему, только
добавляется не глубина а сама вершина.
3. Значение функции I[u], возвращающей индекс в списке глубин d, по которому
была записана глубина вершины u (например на момент входа в вершину).

Запрос
Будем считать, что rmq(d,l,r) возвращает индекс минимального элемента
в d на отрезке [l..r]. Тогда ответом на запрос lca(u, v),
где I[u] <= I[v], будет vtx[rmq(d,I[u],I[v])].
*/

// Реализация:

// ----------