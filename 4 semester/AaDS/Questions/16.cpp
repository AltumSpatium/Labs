// Быстрая сортировка. Оценка сложности без доказательства. Оценка дополнительной памяти. Реализация

/*
Быстрая сортировка, сортировка Хоара (англ. quicksort) — широко известный алгоритм сортировки, разработанный английским
информатиком Чарльзом Хоаром.
Один из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем
O(nlogn) обменов при упорядочении n элементов.

Общая идея алгоритма состоит в следующем:
1. Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов 
массива или же число, вычисленное на основе значений элементов; от выбора этого числа
сильно зависит эффективность алгоритма.
2. Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы
разбить массив на три непрерывных отрезка, следующие друг за другом: «меньшие опорного»,
«равные» и «большие».
3. Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность
операций, если длина отрезка больше единицы.
На практике массив обычно делят не на три, а на две части: например,
«меньшие опорного» и «равные и большие»; такой подход в общем случае эффективнее,
так как упрощает алгоритм разделения.

На входе массив a[0]...a[N] и опорный элемент p, по которому будет производиться разделение.

1. Введем два указателя: i и j. В начале алгоритма они указывают, соответственно, на
левый и правый конец последовательности.
2. Будем двигать указатель i с шагом в 1 элемент по направлению к концу массива,
пока не будет найден элемент a[i] >= p. Затем аналогичным образом начнем двигать
указатель j от конца массива к началу, пока не будет найден a[j] <= p.
3. Далее, если i <= j, меняем a[i] и a[j] местами и продолжаем двигать i,j по тем же
правилам...
4. Повторяем шаг 3, пока i <= j.

Рассмотрим работу процедуры для массива a[0]...a[6] и опорного элемента p = a[3].

Исходное положение:
4 9 7 6 2 3 8
^     -     ^
i           j

Положение первого обмена:
4 9 7 6 2 3 8
  ^   -   ^
  i       j

Положение второго обмена:
4 3 7 6 2 9 8
    ^ - ^
    i   j

Конец процедуры:
4 3 2 6 7 9 8
    ^ - ^
    j   i

Теперь массив разделен на две части: все элементы левой меньше либо равны p, все элементы
правой - больше, либо равны p. Разделение завершено.

Ясно, что операция разделения массива на две части относительно опорного элемента
занимает время O(n). Поскольку все операции разделения, проделываемые на одной
глубине рекурсии, обрабатывают разные части исходного массива, размер которого постоянен,
суммарно на каждом уровне рекурсии потребуется также O(n) операций. Следовательно, 
общая сложность алгоритма определяется лишь количеством разделений, то
есть глубиной рекурсии. Глубина рекурсии, в свою очередь, зависит от сочетания входных
данных и способа определения опорного элемента.

Лучший случай.
В наиболее сбалансированном варианте при каждой операции разделения массив делится
на две почти одинаковые части, следовательно, максимальная глубина рекурсии, при которой
размеры обрабатываемых подмассивов достигнут 1, составит log_2 n. В результате количество
сравнений, совершаемых быстрой сортировкой, было бы равно значению рекурсивного 
выражения C_n = 2 * C_n/2 + n, что даёт общую сложность алгоритма
O(nlog_2 n).

Среднее.
Среднюю сложность при случайном распределении входных данных можно оценить лишь
вероятностно.
Прежде всего необходимо заметить, что в действительности необязательно, чтобы опорный 
элемент всякий раз делил массив на две одинаковых части. Например, если на каждом этапе
будет происходить разделение на массивы длиной 75 % и 25 % от исходного, глубина рекурсии
будет равна log_4/3 n, а это по-прежнему даёт сложность O(nlogn). Вообще, при любом
фиксированном соотношении между левой и правой частями разделения сложность алгоритма
будет той же, только с разными константами.
Будем считать «удачным» разделением такое, при котором опорный элемент окажется среди
центральных 50 % элементов разделяемой части массива; ясно, вероятность удачи при
случайном распределении элементов составляет 0,5. При удачном разделении размеры выделенных
подмассивов составят не менее 25 % и не более 75 % от исходного. Поскольку каждый
выделенный подмассив также будет иметь случайное распределение, все эти рассуждения 
применимы к любому этапу сортировки и любому исходному фрагменту массива.
Удачное разделение даёт глубину рекурсии не более log_4/3 n. Поскольку вероятность
удачи равна 0,5, для получения k удачных разделений в среднем потребуется 2 * k
рекурсивных вызовов, чтобы опорный элемент k раз оказался среди центральных 50 %
массива. Применяя эти соображения, можно заключить, что в среднем глубина рекурсии
не превысит 2 * log_4/3 n, что равно O(log n) А поскольку на каждом уровне рекурсии
по-прежнему выполняется не более O(n) операций, средняя сложность составит O(nlog n).

Худший случай.
В самом несбалансированном варианте каждое разделение даёт два подмассива размерами
1 и n-1, то есть при каждом рекурсивном вызове больший массив будет на 1 короче,
чем в предыдущий раз. Такое может произойти, если в качестве опорного на каждом этапе
будет выбран элемент либо наименьший, либо наибольший из всех обрабатываемых.
При простейшем выборе опорного элемента — первого или последнего в массиве,— такой 
эффект даст уже отсортированный (в прямом или обратном порядке) массив, для
среднего или любого другого фиксированного элемента «массив худшего случая» также
может быть специально подобран. В этом случае потребуется n-1 операций разделения,
а общее время работы составит \sum_{i=0}^n (n-i) = O(n^2) операций, то есть
сортировка будет выполняться за квадратичное время. Но количество обменов и,
соответственно, время работы — это не самый большой его недостаток. Хуже то,
что в таком случае глубина рекурсии при выполнении алгоритма достигнет n, что
будет означать n-кратное сохранение адреса возврата и локальных переменных процедуры
разделения массивов. Для больших значений n худший случай может привести к
исчерпанию памяти (переполнению стека) во время работы программы.
*/

// Реализация:

/* Быстрая сортировка, за O(nlogn) */
void quicksort(int *a, int l, int r)
{
	int m = a[l + (r - l) / 2];
	int i = l, j = r;

	while (i <= j)
	{
		while (a[i] < m) i++;
		while (a[j] > m) j--;

		if (i <= j)
		{
			swap(a[i], a[j]);
			i++;
			j--;
		}
	}

	if (i < r)
		quicksort(i, r);
	if (j > l)
		quicksort(l, j);
}