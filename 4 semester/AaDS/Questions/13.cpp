// Очередь с приоритетами. Куча. Реализация удаления элемента из кучи

/*
Очередь с приоритетом (англ. priority queue) — абстрактный тип данных в программировании,
поддерживающий две обязательные операции — добавить элемент и извлечь максимум.
Предполагается, что для каждого элемента можно вычислить его приоритет — действительное
число или в общем случае элемент линейно упорядоченного множества.

Основные методы, реализуемые очередью с приоритетом, следующие:
insert(ключ, значение) — добавляет пару (ключ, значение) в хранилище;
extract_minimum() — возвращает пару (ключ, значение) с минимальным значением ключа,
удаляя её из хранилища.
При этом меньшее значение ключа соответствует более высокому приоритету.
В некоторых случаях более естественен рост ключа вместе с приоритетом. Тогда второй
метод можно назвать extract_maximum().
Есть ряд реализаций в которых обе основные операции выполняются в худшем случае за время,
ограниченное O(log n), где n — количество хранимых пар.

В качестве примера очереди с приоритетом можно рассмотреть список задач работника. Когда
он заканчивает одну задачу, он переходит к очередной — самой приоритетной
(ключ будет величиной, обратной приоритету) — то есть выполняет операцию
извлечения максимума. Начальник добавляет задачи в список, указывая их приоритет,
то есть выполняет операцию добавления элемента.

Куча — это специализированная структура данных типа дерево, которая удовлетворяет свойству
кучи: если B является узлом-потомком узла A, то ключ(A) ≥ ключ(B). Из этого следует,
что элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда
такие кучи называют max-кучами (в качестве альтернативы, если сравнение перевернуть, то
наименьший элемент будет всегда корневым узлом, такие кучи называют min-кучами).

Куча является максимально эффективной реализацией абстрактного типа данных,
который называется очередью с приоритетом.

Удобнее всего двоичную кучу хранить в виде массива a[0..n-1], у которого нулевой элемент,
a[0] — элемент в корне, а потомками элемента a[i] являются a[2i+1] и a[2i+2].
Высота кучи определяется как высота двоичного дерева. То есть она равна количеству
рёбер в самом длинном простом пути, соединяющем корень кучи с одним из её
листьев. Высота кучи есть O(logn), где n — количество узлов дерева.
Чаще всего используют кучи для минимума (когда предок не больше детей) и для максимума
(когда предок не меньше детей).
Двоичные кучи используют, например, для того, чтобы извлекать минимум из набора чисел
за O(logn).

Если в куче изменяется один из элементов, то она может перестать удовлетворять свойству
упорядоченности. Для восстановления этого свойства служат процедуры siftDown
(просеивание вниз) и siftUp (просеивание вверх). Если значение измененного элемента
увеличивается, то свойства кучи восстанавливаются функцией siftDown. Работа
процедуры: если i-й элемент меньше, чем его сыновья, всё поддерево уже является
кучей, и делать ничего не надо. В противном случае меняем местами i-й элемент с
наименьшим из его сыновей, после чего выполняем siftDown для этого сына. Процедура
выполняется за время O(logn).

Если значение измененного элемента уменьшается, то свойства кучи восстанавливаются
функцией siftUp.
Работа процедуры: если элемент больше своего отца, условие 1 соблюдено для всего
дерева, и больше ничего делать не нужно. Иначе, мы меняем местами его с отцом.
После чего выполняем siftUp для этого отца. Иными словами, слишком маленький элемент
всплывает наверх. Процедура выполняется за время O(logn). 
*/

// Реализация:

/* Куча */
class Heap
{
	int h[100000];
	int tail = 0;

	Heap() {}

	/* Просеивание вниз */
	void siftDown(int i)
	{
		while ((2 * i + 1) < tail)
		{
			int l = 2 * i + 1;
			int r = 2 * i + 2;
			int j = l;

			if (a[r] < a[l])
			{
				j = r;
			}

			if (a[i] <= a[j])
				break;

			swap(a[i], a[j]);
			i = j;
		}
	}

	/* Удаление элемента из кучи */
	void delete(int key)
	{
		swap(a[0], a[tail]);
		siftDown(0);
		tail--;
	}
}